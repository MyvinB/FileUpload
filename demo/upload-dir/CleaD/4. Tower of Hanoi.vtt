WEBVTT

00:02.260 --> 00:09.650
To show the application of recursion that it's nothing better than a dot of Hanoi that often is a very

00:09.650 --> 00:10.850
interesting puzzle.

00:11.270 --> 00:14.300
And many of you may already know about it.

00:14.810 --> 00:22.630
So there is a story that there's a place called Hanoi in Vietnam vet that are treat us and with about

00:22.630 --> 00:31.400
200 disks and the monks there have to move all their deaths from one hour to hour by using certain rules

00:31.730 --> 00:37.710
and it is said that by the time all the best sort of move from one end to the other they're very real.

00:37.730 --> 00:44.140
And but the world has already ended many times now and it's probably become quite boring to even talk

00:44.140 --> 00:44.730
about it.

00:44.890 --> 00:45.490
But anyway.

00:45.670 --> 00:47.930
So let's go over the rules of the puzzle.

00:48.220 --> 00:48.840
OK.

00:49.210 --> 00:57.580
Now here we have three dollars a b and c and we have some disks in it which are aged in the increasing

00:57.640 --> 01:00.290
order of size from top to bottom.

01:00.490 --> 01:09.490
And what we're supposed to do is to move all the disks from our A C using B as an intermediate such

01:09.490 --> 01:15.490
that at no point of time a big this comes on top of a smaller one.

01:15.490 --> 01:16.490
All right.

01:16.900 --> 01:21.870
And one more rule is that we can only move one disk at a time.

01:21.940 --> 01:22.520
All right.

01:23.400 --> 01:26.530
So let's look at a few examples to me the idea here.

01:27.060 --> 01:30.160
So let's say we just have one this.

01:30.200 --> 01:31.090
So this is simple.

01:31.090 --> 01:37.870
We can just move this one from the door to tarsi directly and we have the might of it we have named

01:37.870 --> 01:44.270
the towers and numbered the disk so that we can track the movement and in our program when we write

01:44.270 --> 01:47.490
when we will be printing out these messages.

01:47.490 --> 01:48.050
All right.

01:49.440 --> 01:54.760
So if there are two disks we number them as 1 and 2 1 being on top of two.

01:54.770 --> 01:55.330
All right.

01:56.240 --> 01:59.520
And this order of numbering is important for them.

01:59.570 --> 02:05.180
So in general we'll start numbering the top most disk as one which would also happen to be the disk

02:05.180 --> 02:12.000
with the smallest radius and then keep increasing the numbers as we go down the stack of disks.

02:12.310 --> 02:15.590
And this case of two disks is also quite simple.

02:15.850 --> 02:21.670
We first moved this one from A to B then what do we do.

02:21.670 --> 02:29.290
Move disk to it to see right and finally move this one from Tarby to seat.

02:29.380 --> 02:30.070
Right.

02:30.520 --> 02:34.970
And this was also quite simple and something which everyone can figure out.

02:36.330 --> 02:42.670
Then what about if we have three disks and you will notice that by adding more disks the complexity

02:42.670 --> 02:43.750
of the problem increases.

02:43.780 --> 02:50.040
And slowly with a few more days it will become much harder to write all the steps correctly.

02:50.140 --> 02:55.300
Anyways so before moving on you may want to pause the video here and ride the steps yourself.

02:56.760 --> 02:58.520
This one is also quite easy.

03:01.330 --> 03:09.750
So what we can do is that we move this one to see diary then move this to from A to B.

03:10.650 --> 03:20.500
Move this one from C to be moved disc three from A to C and now we would like to move both these discs

03:20.640 --> 03:23.810
1 and 2 to downwards seat.

03:24.560 --> 03:30.400
But because we can only move one day at a time and without keeping the bigger task on top of the smaller

03:30.400 --> 03:39.610
one at any point of time we first need to move this one from DARBEE to Dhari and then move disk to from

03:40.240 --> 03:45.050
B to C and then finally move this one from it to see.

03:45.220 --> 03:46.120
All right.

03:46.750 --> 03:50.970
And this was a little more intense than the first two cases.

03:51.520 --> 03:53.620
And as the number of entries.

03:54.000 --> 03:57.330
I didn't define the steps become increasingly complex.

03:57.700 --> 04:03.160
And actually it is so complex that it will really be hard to write a program which moves these discs

04:03.220 --> 04:04.560
iteratively.

04:04.750 --> 04:10.270
And this is where recursion comes to help and makes this problem quite easy to program.

04:10.330 --> 04:15.560
All you have to do is to focus a little and align your thoughts along the lines of percussion.

04:15.730 --> 04:20.300
So let's say we write that move which makes for better meters.

04:20.320 --> 04:27.100
The first one is the number of tasks that need to be moved and then the other three parameters can be

04:27.100 --> 04:31.260
of God or the string types representing the others.

04:31.270 --> 04:35.320
So the first one out of these three is Dobber from.

04:35.320 --> 04:37.590
So we buzzed it here.

04:38.200 --> 04:44.510
The second Stauber to that is that discs to be moved from our age to Z.

04:44.950 --> 04:48.580
And the third parameter is the intermediate dullard.

04:48.940 --> 04:51.640
Very Busbee as argument.

04:51.640 --> 04:57.850
So then we call the move method with these Behrami does we mean that move and disk's from start to tarsi

04:58.090 --> 05:04.350
using Tavor we as the intermediate and first you should convince yourself that this is possible.

05:04.870 --> 05:09.930
That is we can move all these steps from it to C using another type.

05:10.660 --> 05:13.210
And if you're convinced let's proceed.

05:13.900 --> 05:22.090
So if we can do that it essentially means that we should be able to move these and minus one discs from

05:22.120 --> 05:27.450
tower to tower be using C as an intermediate.

05:27.460 --> 05:28.470
Right.

05:28.480 --> 05:29.710
Think about it.

05:30.820 --> 05:33.420
Because the end of the disk is the largest in radius.

05:33.520 --> 05:35.080
It can remain untouched.

05:35.200 --> 05:40.120
When we are moving those other and Manasquan discs like that right.

05:40.660 --> 05:47.710
So we should be able to move these and minus one discs from it to be using C which means that we can

05:47.710 --> 05:55.300
call the movement had fought and minus one discs from it to be using CPP isn't it.

05:55.480 --> 06:02.130
Notice that the order of arguments for from tower to tower and using it has changed.

06:02.150 --> 06:11.160
All right then we can move disc and from it to see which is what we can print.

06:13.030 --> 06:20.890
And then we recursively move these in minus 1 disks from our b c using our aid.

06:21.790 --> 06:27.990
So we can again call the move method recursively with this different set of better meters.

06:30.690 --> 06:34.660
And this whole recursive approach just needs to be singing a little.

06:35.160 --> 06:40.690
And to help with that let's revisit that tree this example again.

06:40.890 --> 06:48.210
So here what you're saying is that we want to move three discs from our A C using double B which means

06:48.420 --> 06:57.930
that we can move two discs from A to B using C and what we did earlier was that we moved this one from

06:57.960 --> 07:05.290
A to Z then we moved this to from A to B and then moved this one from C to be.

07:05.880 --> 07:12.390
So essentially the state of the system right now is exactly as if we moved to do this from our it to

07:12.390 --> 07:14.050
be using a seat.

07:14.420 --> 07:15.070
Right.

07:17.370 --> 07:19.370
Which was done recursively.

07:19.680 --> 07:22.200
And we don't really care about the details.

07:23.740 --> 07:25.460
So we are done with this part.

07:25.840 --> 07:28.940
Now we move discs 3 from a to z.

07:32.250 --> 07:38.210
And finally we move these two discs from B to C using our aid.

07:38.880 --> 07:52.710
And if we see that it does that is what we end up doing right.

07:52.740 --> 07:57.670
So as you can see thinking recursively makes this problem much easier to solve.

07:57.840 --> 08:03.880
But of course it needs a little practice and patience to be able to align your mind in that direction.

08:04.320 --> 08:11.160
And of course we need to put the braking condition but let's implement this program and we will talk

08:11.160 --> 08:15.350
about the braking condition that before moving on to the next lecture.

08:15.360 --> 08:19.310
I suggest that you try implementing the program yourself first.

08:19.380 --> 08:23.430
It's ok to try and fail but it's not ok not to have to write or write.
