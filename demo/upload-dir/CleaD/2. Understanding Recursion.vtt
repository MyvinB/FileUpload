WEBVTT

00:02.090 --> 00:08.470
Now let's try to understand how recursion works and why would we get that stack overflow error.

00:08.490 --> 00:16.620
In case you forgot the braking condition or if the depth of recursion is big so let's use the factorial

00:16.620 --> 00:18.460
program to understand this.

00:18.490 --> 00:24.870
Now as you may know that the program's runtime usually creates a stack which is called a method a stack

00:24.930 --> 00:31.450
autocall stack using which it keeps track of local variables or expression evaluation etc..

00:31.590 --> 00:38.110
Now this Carlstadt in context of recursive method is also called less because in a stack it's one and

00:38.110 --> 00:40.830
the same thing just a different name.

00:40.840 --> 00:47.400
Now let's say that the factorial method is called with a parameter type inside the factory method it

00:47.410 --> 00:49.800
checks if the parameter is zero.

00:50.070 --> 00:51.750
And it is not.

00:51.780 --> 00:59.700
So this method returns 5 into that total of food but factorial for itself is a method call whose value

00:59.730 --> 01:01.470
is not yet known.

01:01.500 --> 01:09.120
So this expression even to real food is stored in what is called as a stack frame and pushed into the

01:09.420 --> 01:11.120
recursion stack.

01:11.520 --> 01:14.250
And now the call is made to factorial 4.

01:14.610 --> 01:18.110
So this method is called again with a parameter for.

01:18.570 --> 01:24.660
Then again called that effect to Real Madrid and so forth into vectorial tree whose value is unknown.

01:24.660 --> 01:30.410
So this expression is stored in a stack frame and pushed down the recursion stack.

01:30.840 --> 01:32.970
And this keeps on happening.

01:38.650 --> 01:41.530
Until a known value is returned.

01:42.040 --> 01:49.210
So now we know that factorial of 0 is 1 and this value is replaced in the stack frame which has factorial

01:49.210 --> 01:52.410
zero as part of the expression to be evaluated.

01:52.810 --> 01:57.410
So this value is replaced in that stack frame to get the value of factorial 1.

01:58.650 --> 02:03.600
And we keep popping stack frames and replacing the calculated factorial values

02:09.680 --> 02:16.400
until all the stack frames are bought from the wreckage in the stack and the value of the expression

02:16.460 --> 02:23.620
of the last stack frame is the result of that because of method called and that is the reason why.

02:23.680 --> 02:30.460
If you forget the braking condition you get stack overflow error because the method keeps pushing stack

02:30.460 --> 02:34.160
frames into the stack never reaching the breaking condition.

02:34.270 --> 02:38.530
And ultimately the stack is full and it overflows.

02:38.590 --> 02:47.260
All right and sometimes you may also get a stack overflow error even after having a breaking condition.

02:47.650 --> 02:54.250
And that would happen if the BECAUSE IF call is too deep for example you call them with a very large

02:54.250 --> 03:00.300
bet the value that is there is a whole bunch of stack seems to be pushed into the stack before the end.

03:00.300 --> 03:02.140
And so again we arrived at.
